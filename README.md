# Face Recognition using Siamese Network

This project aims to detect and recognize human faces from 1000 classes. MTCNN and Haar Cascades algorithms are utilized to detect and crop faces. Siamese Network is used to compare two faces and classify whether they are the same or not. Distance between face encodings generated by the Embedding network  is used as a metric to judge the similarity of two faces. The Embedding network is trained using the Triplet Loss, which requires efficient Triplet Mining.


## Getting Started

### Prerequisites
Running this project on your local system requires the following packages to be installed :

* numpy
* matplotlib
* PIL
* mtcnn
* cv2
* keras
    
 They can be installed from the Python Package Index using pip as follows :
 
     pip install numpy
     pip install matplotlib
     pip install Pillow
     pip install mtcnn
     pip install opencv-python
     pip install Keras
     
     
 You can also use [Google Colab](https://colab.research.google.com/) in a Web Browser without needing to install the mentioned packages.
 
### Usage
This project is implemented as an interactive Jupyter Notebook. You just need to open the notebook on your local system or on [Google Colab](https://colab.research.google.com/) and execute the code cells in sequential order. The function of each code cell is properly explained with the help of comments.</br>

## Tools Used
* [NumPy](https://numpy.org/) : Used for storing and manipulating high dimensional arrays.
* [Matplotlib](https://matplotlib.org/) : Used for plotting.
* [PIL](https://pillow.readthedocs.io/en/stable/) : Used for loading image files.
* [MTCNN](https://pillow.readthedocs.io/en/stable/) : Used for detecting and cropping faces.
* [OpenCV](https://opencv.org/) : Used for loading Haar Cascades and manipulating video streams.
* [Keras](https://keras.io/) : Used for designing and training the Embedding model.
* [Google Colab](https://colab.research.google.com/) : Used as the developement environment for executing high-end computations on its backend GPUs/TPUs and for editing Jupyter Notebook. 



## Project Description and Results
### Face Detection
[Multi-task Cascaded Convolutional Networks](https://kpzhang93.github.io/MTCNN_face_detection_alignment/) (MTCNN) is used for face detection during the training process as it provides an impressive accuracy. Haar Cascades is preferred during realtime applications as MTCNN is computationally slow. However this results in trading off a small amount of accuracy. 

### Embedding Network
A simple model is used as the Embedding network for generating face encodings in this project. It expects **60x60x1** Gray images with pixel values normalized across all the channels, to generate **150** dimensional face encodings.</br>


### Training the Embedding Network
Embedding network is trained using the following trainer model :
<p align="center">
  <img src=Images/emb_trainer_model.png>
</p>

This trainer model is fed with a batch of Triplets. A Triplet is a set of 3 faces (Anchor, Positive and Negative). Anchor and Positive are faces of the same person, whereas Negative is the face of another person. This Trainer model tries to minimize the Triplet Loss (calculated using face encodings generated by the Embedding network for this batch).

### Triplet Loss
Triplet loss for a batch of Triplets is calculated as :

<img src=Images/Triplet_Loss.png>

Here **m** denotes the no. of Triplets in the batch, **(anchor, positive and negative)** superscript **i** are face encodings (generated by the Embedding network) for the **i**th Triplet in the batch. </br>

**Alpha** is the least margin by which the two distances should be separated.</br>

**distance** is the Euclidean distance between the two 128 dimensional encodings. Before calculating this distance, each encoding is **L2 Normalized**.

### Triplet Mining
There are 3 kind of Triplets :
* Easy Triplet : **distance(anchor,positive) + alpha < distance(anchor,negative)**
* Semi-hard Triplet : **distance(anchor,positive) < distance(anchor,negative) < distance(anchor,positive) + alpha**
* Hard Triplet : **distance(anchor,negative) < distance(anchor,positive)**

It can be seen that Easy triplets have loss=0, making them useless for training the Embedding network. So mostly Hard and Semi-hard Triplets are desired for training the Embedding network. Triplet Mining is therefore required to find triplets having maximum impact on the training process.

### Triplet Output
<p align="center">
  <img src=Images/triplets.JPG>
</p>
